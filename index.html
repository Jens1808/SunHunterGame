<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SUN HUNTER</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Arial Black', Arial, sans-serif;
            background: #000;
            cursor: crosshair;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #backgroundCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            color: #FFD700;
            text-shadow: 2px 2px 4px #000;
            z-index: 10;
        }

        #ui div {
            font-size: 24px;
        }

        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .menu-box {
            background: linear-gradient(to bottom, #1a1a3e, #0a0a2e);
            border: 4px solid #FFD700;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
            min-width: 400px;
        }

        .menu-box h1 {
            font-size: 60px;
            color: #FFD700;
            text-shadow: 4px 4px 8px #000, 0 0 30px #FF6600;
            margin-bottom: 10px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        .menu-box h2 {
            font-size: 40px;
            color: #FFD700;
            text-shadow: 2px 2px 4px #000;
            margin-bottom: 20px;
        }

        .menu-box p {
            font-size: 20px;
            color: #FFF;
            text-shadow: 2px 2px 4px #000;
            margin-bottom: 20px;
        }

        .menu-box .subtitle {
            font-size: 16px;
            color: #AAA;
            margin-bottom: 30px;
        }

        @keyframes glow {
            from { text-shadow: 4px 4px 8px #000, 0 0 30px #FF6600; }
            to { text-shadow: 4px 4px 8px #000, 0 0 50px #FFD700, 0 0 80px #FF6600; }
        }

        .btn {
            display: block;
            width: 100%;
            padding: 15px 30px;
            margin: 10px 0;
            font-size: 22px;
            font-family: 'Arial Black', Arial, sans-serif;
            background: linear-gradient(to bottom, #FFD700, #FF8C00);
            border: 3px solid #FFF;
            border-radius: 10px;
            color: #000;
            cursor: pointer;
            text-shadow: none;
            box-shadow: 0 5px 20px rgba(255,215,0,0.3);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn:hover {
            transform: scale(1.03);
            box-shadow: 0 8px 30px rgba(255,215,0,0.6);
        }

        .btn-secondary {
            background: linear-gradient(to bottom, #666, #333);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .btn-secondary:hover {
            box-shadow: 0 8px 25px rgba(100,100,100,0.5);
        }

        .btn-danger {
            background: linear-gradient(to bottom, #ff4444, #cc0000);
        }

        .btn-small {
            display: inline-block;
            width: auto;
            padding: 10px 20px;
            font-size: 16px;
            margin: 5px;
        }

        #highscoreList {
            list-style: none;
            margin: 20px 0;
            text-align: left;
            max-height: 300px;
            overflow-y: auto;
        }

        #highscoreList li {
            font-size: 18px;
            color: #FFF;
            padding: 8px 15px;
            border-bottom: 1px solid #FFD700;
        }

        #highscoreList li:first-child {
            color: #FFD700;
            font-size: 22px;
        }

        #hitEffect {
            position: absolute;
            pointer-events: none;
            z-index: 15;
            font-size: 30px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px #000;
            animation: floatUp 1s ease-out forwards;
            display: none;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
        }

        #crosshair {
            position: absolute;
            pointer-events: none;
            z-index: 100;
            width: 40px;
            height: 40px;
            transform: translate(-50%, -50%);
        }

        #muzzleFlash {
            position: absolute;
            pointer-events: none;
            z-index: 14;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #FFF 0%, #FFD700 30%, transparent 70%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }

        .controls-info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            font-size: 14px;
            color: #AAA;
        }

        .controls-info span {
            color: #FFD700;
        }

        .save-slots {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }

        .save-slot {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border: 2px solid #444;
            border-radius: 10px;
            color: #FFF;
        }

        .save-slot.has-save {
            border-color: #FFD700;
        }

        .save-slot-info {
            text-align: left;
        }

        .save-slot-name {
            font-size: 18px;
            color: #FFD700;
        }

        .save-slot-details {
            font-size: 14px;
            color: #AAA;
        }

        .volume-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
            color: #FFF;
        }

        .volume-control input[type="range"] {
            width: 150px;
            cursor: pointer;
        }

        input[type="text"] {
            padding: 12px;
            font-size: 18px;
            border-radius: 8px;
            border: 2px solid #FFD700;
            background: rgba(0,0,0,0.5);
            color: #FFF;
            text-align: center;
            width: 80%;
        }

        input[type="text"]::placeholder {
            color: #888;
        }

        .hidden {
            display: none !important;
        }

        #pauseIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            color: #FFD700;
            text-shadow: 4px 4px 8px #000;
            z-index: 30;
            display: none;
        }

        /* Pause Button f√ºr Touch-Ger√§te */
        #pauseBtn {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            background: linear-gradient(to bottom, rgba(255,215,0,0.9), rgba(255,140,0,0.9));
            border: 3px solid #FFF;
            border-radius: 50%;
            font-size: 24px;
            color: #000;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        #pauseBtn:active {
            transform: scale(0.9);
            background: linear-gradient(to bottom, rgba(255,140,0,0.9), rgba(255,100,0,0.9));
        }

        /* Sarkastische Spr√ºche */
        #snarkyMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            font-weight: bold;
            color: #FFF;
            text-shadow: 3px 3px 6px #000, 0 0 20px #FF6600;
            z-index: 200;
            text-align: center;
            padding: 20px 40px;
            background: rgba(0,0,0,0.8);
            border: 3px solid #FFD700;
            border-radius: 15px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            max-width: 90%;
        }

        #snarkyMessage.show {
            opacity: 1;
            animation: snarkyPulse 0.5s ease-out;
        }

        @keyframes snarkyPulse {
            0% { transform: translate(-50%, -50%) scale(0.5); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        /* Highscore Celebration */
        .highscore-celebration {
            animation: celebrationGlow 0.5s ease-in-out infinite alternate;
        }

        @keyframes celebrationGlow {
            from {
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.5), 0 0 60px rgba(255, 100, 0, 0.3);
                border-color: #FFD700;
            }
            to {
                box-shadow: 0 0 50px rgba(255, 215, 0, 0.8), 0 0 100px rgba(255, 100, 0, 0.5);
                border-color: #FFF;
            }
        }

        /* Konfetti Canvas */
        #confettiCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 150;
        }

        /* New Highscore Badge */
        .new-highscore-badge {
            display: inline-block;
            background: linear-gradient(45deg, #FFD700, #FF6600, #FFD700);
            background-size: 200% 200%;
            animation: gradientShift 1s ease infinite;
            color: #000;
            font-weight: bold;
            padding: 8px 20px;
            border-radius: 20px;
            margin: 10px 0;
            font-size: 18px;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Mobile Optimierungen */
        @media screen and (max-width: 768px) {
            #ui {
                padding: 8px 60px 8px 10px;
                flex-wrap: wrap;
                gap: 5px;
            }

            #ui div {
                font-size: 14px;
            }

            .menu-box {
                min-width: auto;
                width: 90%;
                max-width: 400px;
                padding: 25px 20px;
                margin: 10px;
            }

            .menu-box h1 {
                font-size: 36px;
            }

            .menu-box h2 {
                font-size: 28px;
            }

            .menu-box p {
                font-size: 16px;
            }

            .menu-box .subtitle {
                font-size: 14px;
            }

            .btn {
                padding: 12px 20px;
                font-size: 18px;
            }

            .btn-small {
                padding: 8px 15px;
                font-size: 14px;
            }

            .controls-info {
                font-size: 12px;
                padding: 10px;
            }

            .save-slot {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }

            .save-slot-info {
                text-align: center;
            }

            .volume-control {
                flex-direction: column;
                gap: 8px;
            }

            .volume-control input[type="range"] {
                width: 100%;
            }

            #highscoreList li {
                font-size: 14px;
                padding: 6px 10px;
            }

            #highscoreList li:first-child {
                font-size: 16px;
            }

            input[type="text"] {
                width: 100%;
                font-size: 16px;
            }

            #pauseBtn {
                width: 45px;
                height: 45px;
                font-size: 20px;
            }
        }

        @media screen and (max-width: 480px) {
            #ui div {
                font-size: 12px;
            }

            .menu-box h1 {
                font-size: 28px;
            }

            .menu-box h2 {
                font-size: 22px;
            }

            .btn {
                padding: 10px 15px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas>
    <canvas id="gameCanvas"></canvas>

    <div id="ui" class="hidden">
        <div id="scoreDisplay">PUNKTE: 0</div>
        <div id="levelDisplay">LEVEL: 1</div>
        <div id="timeDisplay">ZEIT: 60</div>
        <div id="comboDisplay">KOMBO: x1</div>
    </div>

    <!-- Pause Button f√ºr Touch -->
    <button id="pauseBtn" class="hidden" onclick="pauseGame()">‚è∏</button>

    <div id="pauseIndicator">‚è∏ PAUSIERT</div>

    <!-- Main Menu -->
    <div id="mainMenu" class="menu-overlay">
        <div class="menu-box">
            <h1>‚òÄÔ∏è SUN HUNTER</h1>
            <p class="subtitle">Schie√üe auf die Symbole und sammle Punkte!</p>

            <button class="btn" onclick="startNewGame()">NEUES SPIEL</button>
            <button class="btn btn-secondary" onclick="showLoadMenu()">SPIEL LADEN</button>
            <button class="btn btn-secondary" onclick="showHighscores()">HIGHSCORES</button>
            <button class="btn btn-secondary" onclick="showSettings()">EINSTELLUNGEN</button>

            <div class="controls-info">
                <span>TIPPEN/KLICK</span> = Schie√üen | <span>‚è∏ Button</span> = Pause | <span>M</span> = Musik An/Aus
            </div>
        </div>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu" class="menu-overlay hidden">
        <div class="menu-box">
            <h2>‚è∏ PAUSIERT</h2>
            <p>Level: <span id="pauseLevel">1</span> | Punkte: <span id="pauseScore">0</span></p>

            <button class="btn" onclick="resumeGame()">WEITERSPIELEN</button>
            <button class="btn btn-secondary" onclick="showSaveMenu()">SPIEL SPEICHERN</button>
            <button class="btn btn-secondary" onclick="showSettingsInGame()">EINSTELLUNGEN</button>
            <button class="btn btn-danger" onclick="quitToMenu()">HAUPTMEN√ú</button>
        </div>
    </div>

    <!-- Save Menu -->
    <div id="saveMenu" class="menu-overlay hidden">
        <div class="menu-box">
            <h2>üíæ SPIEL SPEICHERN</h2>

            <input type="text" id="savePlayerName" placeholder="Dein Name" maxlength="15" style="margin-bottom: 15px;">

            <div class="save-slots" id="saveSlots"></div>

            <button class="btn btn-secondary" onclick="closeSaveMenu()">ZUR√úCK</button>
        </div>
    </div>

    <!-- Load Menu -->
    <div id="loadMenu" class="menu-overlay hidden">
        <div class="menu-box">
            <h2>üìÇ SPIEL LADEN</h2>

            <div class="save-slots" id="loadSlots"></div>

            <button class="btn btn-secondary" onclick="closeLoadMenu()">ZUR√úCK</button>
        </div>
    </div>

    <!-- Settings Menu -->
    <div id="settingsMenu" class="menu-overlay hidden">
        <div class="menu-box">
            <h2>‚öôÔ∏è EINSTELLUNGEN</h2>

            <div class="volume-control">
                <span>üéµ Musik:</span>
                <input type="range" id="musicVolume" min="0" max="100" value="50" onchange="setMusicVolume(this.value)">
                <span id="musicVolumeLabel">50%</span>
            </div>

            <div class="volume-control">
                <span>üîä Effekte:</span>
                <input type="range" id="sfxVolume" min="0" max="100" value="70" onchange="setSfxVolume(this.value)">
                <span id="sfxVolumeLabel">70%</span>
            </div>

            <button class="btn btn-secondary" onclick="closeSettings()">ZUR√úCK</button>
        </div>
    </div>

    <!-- Level Complete -->
    <div id="levelComplete" class="menu-overlay hidden">
        <div class="menu-box">
            <h2>üéâ LEVEL GESCHAFFT!</h2>
            <p id="levelSnarky" style="color: #FF6600; font-style: italic; margin-bottom: 15px;"></p>
            <p id="levelScore"></p>
            <p id="levelBonus"></p>
            <p id="levelAccuracy"></p>

            <button class="btn" onclick="nextLevel()">N√ÑCHSTES LEVEL</button>
            <button class="btn btn-secondary" onclick="showSaveMenuAfterLevel()">SPEICHERN</button>
        </div>
    </div>

    <!-- Game Over -->
    <div id="gameOver" class="menu-overlay hidden">
        <div class="menu-box" id="gameOverBox">
            <h2 id="gameOverTitle">üíÄ SPIEL VORBEI!</h2>
            <div id="newHighscoreBadge" class="new-highscore-badge hidden">üèÜ NEUER HIGHSCORE! üèÜ</div>
            <p id="gameOverSnarky" style="color: #FF6600; font-style: italic; margin-bottom: 15px;"></p>
            <p id="finalScore"></p>
            <p id="finalLevel"></p>
            <p id="finalAccuracy"></p>

            <input type="text" id="playerName" placeholder="Dein Name" maxlength="15">

            <button class="btn" onclick="saveHighscore()">HIGHSCORE SPEICHERN</button>
            <button class="btn btn-secondary" onclick="restartGame()">NOCHMAL SPIELEN</button>
            <button class="btn btn-secondary" onclick="quitToMenuFromGameOver()">HAUPTMEN√ú</button>
        </div>
    </div>

    <!-- Highscores -->
    <div id="highscoresMenu" class="menu-overlay hidden">
        <div class="menu-box">
            <h2>üèÜ HIGHSCORES</h2>
            <ul id="highscoreList"></ul>
            <button class="btn btn-secondary" onclick="closeHighscores()">ZUR√úCK</button>
        </div>
    </div>

    <div id="hitEffect">+100</div>
    <div id="muzzleFlash"></div>
    <div id="snarkyMessage"></div>
    <canvas id="confettiCanvas"></canvas>

    <svg id="crosshair" viewBox="0 0 40 40" style="background: transparent;">
        <circle cx="20" cy="20" r="15" fill="transparent" stroke="#FF0000" stroke-width="2"/>
        <line x1="20" y1="0" x2="20" y2="12" stroke="#FF0000" stroke-width="2"/>
        <line x1="20" y1="28" x2="20" y2="40" stroke="#FF0000" stroke-width="2"/>
        <line x1="0" y1="20" x2="12" y2="20" stroke="#FF0000" stroke-width="2"/>
        <line x1="28" y1="20" x2="40" y2="20" stroke="#FF0000" stroke-width="2"/>
        <circle cx="20" cy="20" r="3" fill="#FF0000"/>
    </svg>

    <script>
        // ==================== AUDIO SYSTEM ====================
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let musicVolume = 0.5;
        let sfxVolume = 0.7;
        let musicPlaying = false;
        let musicOscillators = [];
        let musicGain;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
                musicGain = audioCtx.createGain();
                musicGain.connect(audioCtx.destination);
                musicGain.gain.value = musicVolume;
            }
        }

        function setMusicVolume(value) {
            musicVolume = value / 100;
            document.getElementById('musicVolumeLabel').textContent = value + '%';
            if (musicGain) {
                musicGain.gain.value = musicVolume;
            }
            localStorage.setItem('sunHunterMusicVolume', value);
        }

        function setSfxVolume(value) {
            sfxVolume = value / 100;
            document.getElementById('sfxVolumeLabel').textContent = value + '%';
            localStorage.setItem('sunHunterSfxVolume', value);
        }

        function loadVolumeSettings() {
            const savedMusic = localStorage.getItem('sunHunterMusicVolume');
            const savedSfx = localStorage.getItem('sunHunterSfxVolume');

            if (savedMusic !== null) {
                document.getElementById('musicVolume').value = savedMusic;
                setMusicVolume(savedMusic);
            }
            if (savedSfx !== null) {
                document.getElementById('sfxVolume').value = savedSfx;
                setSfxVolume(savedSfx);
            }
        }

        // Upbeat casino background music with groove
        let musicNodes = [];
        let beatInterval = null;

        function startBackgroundMusic() {
            if (!audioCtx || musicPlaying) return;
            musicPlaying = true;

            // Ambient pad layer
            const padOsc1 = audioCtx.createOscillator();
            const padOsc2 = audioCtx.createOscillator();
            const padFilter = audioCtx.createBiquadFilter();
            const padGain = audioCtx.createGain();

            padFilter.type = 'lowpass';
            padFilter.frequency.value = 900;
            padOsc1.type = 'sine';
            padOsc2.type = 'triangle';
            padOsc1.frequency.value = 130.81;
            padOsc2.frequency.value = 196;

            padOsc1.connect(padFilter);
            padOsc2.connect(padFilter);
            padFilter.connect(padGain);
            padGain.connect(musicGain);
            padGain.gain.value = 0.06;

            padOsc1.start();
            padOsc2.start();
            musicNodes.push(padOsc1, padOsc2);

            // Start the beat loop
            playBeatLoop();

            // Melodic arpeggios
            playArpeggioLoop();

            // Sparkle effects
            playSparkleLoop();
        }

        function playBeatLoop() {
            if (!musicPlaying || !audioCtx) return;

            const now = audioCtx.currentTime;
            const bpm = 128;
            const beatTime = 60 / bpm;
            const barLength = beatTime * 4;

            // Kick drum pattern (4 on the floor)
            for (let i = 0; i < 4; i++) {
                const kickOsc = audioCtx.createOscillator();
                const kickGain = audioCtx.createGain();
                kickOsc.type = 'sine';
                kickOsc.frequency.setValueAtTime(150, now + i * beatTime);
                kickOsc.frequency.exponentialRampToValueAtTime(40, now + i * beatTime + 0.1);
                kickOsc.connect(kickGain);
                kickGain.connect(musicGain);
                kickGain.gain.setValueAtTime(0.2, now + i * beatTime);
                kickGain.gain.exponentialRampToValueAtTime(0.01, now + i * beatTime + 0.2);
                kickOsc.start(now + i * beatTime);
                kickOsc.stop(now + i * beatTime + 0.3);
            }

            // Snappy hi-hat on off-beats
            for (let i = 0; i < 8; i++) {
                const hihatOsc = audioCtx.createOscillator();
                const hihatGain = audioCtx.createGain();
                const hihatFilter = audioCtx.createBiquadFilter();
                hihatOsc.type = 'square';
                hihatOsc.frequency.value = 8000 + Math.random() * 2000;
                hihatFilter.type = 'highpass';
                hihatFilter.frequency.value = 7000;
                hihatOsc.connect(hihatFilter);
                hihatFilter.connect(hihatGain);
                hihatGain.connect(musicGain);
                const vol = i % 2 === 1 ? 0.04 : 0.02;
                hihatGain.gain.setValueAtTime(vol, now + i * beatTime / 2);
                hihatGain.gain.exponentialRampToValueAtTime(0.001, now + i * beatTime / 2 + 0.05);
                hihatOsc.start(now + i * beatTime / 2);
                hihatOsc.stop(now + i * beatTime / 2 + 0.1);
            }

            // Punchy bass line
            const bassPattern = [130.81, 0, 164.81, 130.81, 0, 146.83, 130.81, 164.81];
            bassPattern.forEach((freq, i) => {
                if (freq === 0) return;
                const bassOsc = audioCtx.createOscillator();
                const bassGain = audioCtx.createGain();
                const bassFilter = audioCtx.createBiquadFilter();
                bassOsc.type = 'sawtooth';
                bassOsc.frequency.value = freq / 2;
                bassFilter.type = 'lowpass';
                bassFilter.frequency.value = 300;
                bassOsc.connect(bassFilter);
                bassFilter.connect(bassGain);
                bassGain.connect(musicGain);
                bassGain.gain.setValueAtTime(0.12, now + i * beatTime / 2);
                bassGain.gain.exponentialRampToValueAtTime(0.01, now + i * beatTime / 2 + 0.2);
                bassOsc.start(now + i * beatTime / 2);
                bassOsc.stop(now + i * beatTime / 2 + 0.25);
            });

            // Clap on 2 and 4
            [1, 3].forEach(beat => {
                const clapOsc = audioCtx.createOscillator();
                const clapGain = audioCtx.createGain();
                const clapFilter = audioCtx.createBiquadFilter();
                clapOsc.type = 'triangle';
                clapOsc.frequency.value = 1500;
                clapFilter.type = 'bandpass';
                clapFilter.frequency.value = 1200;
                clapFilter.Q.value = 2;
                clapOsc.connect(clapFilter);
                clapFilter.connect(clapGain);
                clapGain.connect(musicGain);
                clapGain.gain.setValueAtTime(0.08, now + beat * beatTime);
                clapGain.gain.exponentialRampToValueAtTime(0.001, now + beat * beatTime + 0.1);
                clapOsc.start(now + beat * beatTime);
                clapOsc.stop(now + beat * beatTime + 0.15);
            });

            setTimeout(() => {
                if (musicPlaying) playBeatLoop();
            }, barLength * 1000);
        }

        function playArpeggioLoop() {
            if (!musicPlaying || !audioCtx) return;

            const now = audioCtx.currentTime;
            const bpm = 128;
            const noteTime = 60 / bpm / 2;

            // Casino-style ascending arpeggios
            const arpeggios = [
                [261.63, 329.63, 392, 523.25],     // C major
                [293.66, 369.99, 440, 587.33],     // D major
                [329.63, 415.30, 493.88, 659.25],  // E major
                [293.66, 349.23, 440, 587.33]      // D minor
            ];

            const arpIndex = Math.floor((Date.now() / 4000) % arpeggios.length);
            const arp = arpeggios[arpIndex];

            arp.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();

                osc.type = 'sine';
                osc.frequency.value = freq;
                filter.type = 'lowpass';
                filter.frequency.value = 2000;

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(musicGain);

                gain.gain.setValueAtTime(0, now + i * noteTime);
                gain.gain.linearRampToValueAtTime(0.05, now + i * noteTime + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.01, now + i * noteTime + noteTime * 0.9);

                osc.start(now + i * noteTime);
                osc.stop(now + i * noteTime + noteTime);
            });

            // Descending part
            [...arp].reverse().forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = 'triangle';
                osc.frequency.value = freq * 1.5;
                osc.connect(gain);
                gain.connect(musicGain);

                const offset = arp.length * noteTime;
                gain.gain.setValueAtTime(0, now + offset + i * noteTime);
                gain.gain.linearRampToValueAtTime(0.03, now + offset + i * noteTime + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.01, now + offset + i * noteTime + noteTime * 0.8);

                osc.start(now + offset + i * noteTime);
                osc.stop(now + offset + i * noteTime + noteTime);
            });

            setTimeout(() => {
                if (musicPlaying) playArpeggioLoop();
            }, 2000);
        }

        function playSparkleLoop() {
            if (!musicPlaying || !audioCtx) return;

            const now = audioCtx.currentTime;
            const sparkleNotes = [1046.50, 1174.66, 1318.51, 1396.91, 1567.98, 1760];

            // Random sparkle notes
            for (let i = 0; i < 2; i++) {
                const delay = Math.random() * 1.5;
                const freq = sparkleNotes[Math.floor(Math.random() * sparkleNotes.length)];

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.type = 'sine';
                osc.frequency.value = freq;
                osc.connect(gain);
                gain.connect(musicGain);

                gain.gain.setValueAtTime(0, now + delay);
                gain.gain.linearRampToValueAtTime(0.04, now + delay + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.3);

                osc.start(now + delay);
                osc.stop(now + delay + 0.4);
            }

            setTimeout(() => {
                if (musicPlaying) playSparkleLoop();
            }, 800 + Math.random() * 600);
        }

        function stopBackgroundMusic() {
            musicPlaying = false;
            musicNodes.forEach(node => {
                try { node.stop(); } catch(e) {}
            });
            musicNodes = [];
        }

        function toggleMusic() {
            if (musicPlaying) {
                stopBackgroundMusic();
            } else {
                startBackgroundMusic();
            }
        }

        function playSound(type) {
            if (!audioCtx || sfxVolume === 0) return;

            const masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);
            masterGain.gain.value = sfxVolume;

            switch(type) {
                case 'shoot':
                    playSfxTone(150, 50, 0.1, 'square', masterGain, true);
                    break;
                case 'jackpot': // Sonne
                    playSfxChord([523.25, 659.25, 783.99, 1046.50], 0.5, 'sine', masterGain);
                    setTimeout(() => playSfxChord([587.33, 739.99, 880, 1174.66], 0.3, 'sine', masterGain), 150);
                    setTimeout(() => playSfxChord([659.25, 830.61, 987.77, 1318.51], 0.3, 'sine', masterGain), 300);
                    break;
                case 'chaching': // Diamant
                    playSfxTone(1200, 1200, 0.1, 'sine', masterGain);
                    setTimeout(() => playSfxTone(1500, 1500, 0.1, 'sine', masterGain), 100);
                    setTimeout(() => playSfxTone(1800, 1800, 0.15, 'sine', masterGain), 200);
                    break;
                case 'bell': // Glocke
                    playSfxTone(800, 800, 0.3, 'sine', masterGain);
                    playSfxTone(1200, 1200, 0.3, 'sine', masterGain);
                    break;
                case 'coin': // Melone
                    playSfxTone(900, 900, 0.1, 'square', masterGain);
                    setTimeout(() => playSfxTone(1100, 1100, 0.1, 'square', masterGain), 80);
                    break;
                case 'plop': // Orange
                    playSfxTone(400, 100, 0.1, 'sine', masterGain, true);
                    break;
                case 'ping': // Kirsche
                    playSfxTone(600, 600, 0.08, 'sine', masterGain);
                    break;
                case 'miss':
                    playSfxTone(200, 100, 0.15, 'sawtooth', masterGain, true);
                    break;
                case 'levelup':
                    playSfxTone(440, 440, 0.1, 'sine', masterGain);
                    setTimeout(() => playSfxTone(554.37, 554.37, 0.1, 'sine', masterGain), 100);
                    setTimeout(() => playSfxTone(659.25, 659.25, 0.1, 'sine', masterGain), 200);
                    setTimeout(() => playSfxTone(880, 880, 0.3, 'sine', masterGain), 300);
                    break;
                case 'gameover':
                    playSfxTone(400, 400, 0.3, 'sawtooth', masterGain);
                    setTimeout(() => playSfxTone(300, 300, 0.3, 'sawtooth', masterGain), 300);
                    setTimeout(() => playSfxTone(200, 200, 0.5, 'sawtooth', masterGain), 600);
                    break;
            }
        }

        function playSfxTone(startFreq, endFreq, duration, type, destination, sweep = false) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(destination);
            osc.type = type;
            osc.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
            if (sweep) {
                osc.frequency.exponentialRampToValueAtTime(Math.max(endFreq, 20), audioCtx.currentTime + duration);
            }
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + duration);
        }

        function playSfxChord(frequencies, duration, type, destination) {
            frequencies.forEach(freq => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(destination);
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + duration);
            });
        }

        // ==================== CANVAS SETUP ====================
        const bgCanvas = document.getElementById('backgroundCanvas');
        const bgCtx = bgCanvas.getContext('2d');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            bgCanvas.width = window.innerWidth;
            bgCanvas.height = window.innerHeight;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawBackground(); // Redraw background once
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ==================== GAME STATE ====================
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let level = 1;
        let timeLeft = 60;
        let targets = [];
        let particles = [];
        let timerInterval;
        let shotsFired = 0;
        let shotsHit = 0;
        let combo = 1;
        let lastHitTime = 0;
        let missStreak = 0;

        // ==================== SARKASTISCHE SPR√úCHE ====================
        const snarkyMessages = {
            // Neuer Highscore
            newHighscore: [
                "Wow, du hast tats√§chlich was erreicht. Deine Mutter w√§re... naja, √ºberrascht.",
                "Neuer Highscore! Schade, dass das keinen interessiert.",
                "Gl√ºckwunsch! Jetzt hast du was f√ºr deinen Lebenslauf.",
                "Beeindruckend! F√ºr jemanden der sonst nichts hinkriegt.",
                "Ein neuer Rekord! Deine Katze ist bestimmt stolz.",
                "Historischer Moment! Schreib's dir auf, bevor du's vergisst.",
                "NEUER HIGHSCORE! *Konfetti aus Tr√§nen deiner Gegner*",
                "Du bist jetzt offiziell besser als... naja, du vorher.",
            ],
            // Game Over - schlecht gespielt (unter 1000 Punkte)
            gameOverBad: [
                "Das war's? Ernsthaft?",
                "Meine Oma zielt besser. Sie ist blind.",
                "Hast du mit geschlossenen Augen gespielt?",
                "Versuch's nochmal. Oder lass es. Mir egal.",
                "Das war so schlecht, ich hab Mitleid mit den Symbolen.",
                "Selbst die Kirschen haben dich ausgelacht.",
                "Parkinsons-Simulator erfolgreich abgeschlossen!",
                "Dein Talent ist... woanders. Definitiv woanders.",
            ],
            // Game Over - mittelm√§√üig (1000-5000)
            gameOverMeh: [
                "Naja... es war ein Versuch.",
                "Mittelm√§√üigkeit hat einen neuen Champion!",
                "Nicht schlecht, nicht gut. Einfach... da.",
                "Du bist der Durchschnitt in Person. Gl√ºckwunsch?",
                "Das reicht f√ºr Bronze. Auf der Kreismeisterschaft. Der Unter-10-J√§hrigen.",
                "Immerhin hast du nicht aufgegeben. Das ist... was.",
                "Genau die Energie, die ich von dir erwartet habe.",
            ],
            // Game Over - gut gespielt (5000-15000)
            gameOverGood: [
                "Okay, das war tats√§chlich nicht komplett peinlich.",
                "Hast du heimlich ge√ºbt? Wie traurig.",
                "Nicht schlecht f√ºr jemanden mit zwei linken H√§nden.",
                "Respekt! Du hast meine niedrigen Erwartungen √ºbertroffen.",
                "Das war fast beeindruckend. Fast.",
                "Wow, du kannst ja doch was. Wer h√§tte das gedacht?",
            ],
            // Game Over - sehr gut (√ºber 15000)
            gameOverAmazing: [
                "Okay, das war tats√§chlich gut. Ich hasse es, das zuzugeben.",
                "Hast du kein Leben? Das erkl√§rt einiges.",
                "Beeindruckend! Aber geh mal wieder nach drau√üen.",
                "Du Tryhard. Respekt, aber auch: Cringe.",
                "Das war legitim gut. Ich bin fast... beeindruckt?",
                "Pro-Gamer-Move! Schade, dass niemand zuschaut.",
            ],
            // Level geschafft
            levelComplete: [
                "Weiter so, Overachiever.",
                "Ein Level geschafft. Nur noch 9 bis zur totalen Zeitverschwendung.",
                "Nicht schlecht! Jetzt wird's schwerer. Viel Spa√ü damit.",
                "GG! ...sagte niemand jemals √ºber dein Gameplay.",
                "Level up! Dein Ego auch, wahrscheinlich.",
                "Geschafft! Deine Prokrastination zahlt sich aus.",
            ],
            // Hoher Combo
            highCombo: [
                "Combo-K√∂nig! Oder so.",
                "Du triffst ja echt! Zuf√§lle gibt's...",
                "COMBO! Jemand hat heute seine Brille gefunden.",
                "Feuer frei! Du Irrer!",
                "Killstreak! ...in einem Obstspiel. Gro√üartig.",
            ],
            // Miss Streak
            missStreak: [
                "Triffst du auch mal was?",
                "Die Symbole bewegen sich. Nur zur Info.",
                "Vielleicht hilft eine Brille?",
                "Aim: 404 Not Found",
                "Stormtrooper-Ausbildung erfolgreich!",
            ],
        };

        function getRandomSnarky(category) {
            const messages = snarkyMessages[category];
            return messages[Math.floor(Math.random() * messages.length)];
        }

        function showSnarkyMessage(message, duration = 2500) {
            const el = document.getElementById('snarkyMessage');
            el.textContent = message;
            el.classList.add('show');

            setTimeout(() => {
                el.classList.remove('show');
            }, duration);
        }

        // ==================== KONFETTI SYSTEM ====================
        const confettiCanvas = document.getElementById('confettiCanvas');
        const confettiCtx = confettiCanvas.getContext('2d');
        let confettiPieces = [];
        let confettiAnimating = false;

        function resizeConfettiCanvas() {
            confettiCanvas.width = window.innerWidth;
            confettiCanvas.height = window.innerHeight;
        }
        resizeConfettiCanvas();
        window.addEventListener('resize', resizeConfettiCanvas);

        function createConfetti(count = 150) {
            confettiPieces = [];
            const colors = ['#FFD700', '#FF6600', '#FF0000', '#00FF00', '#00BFFF', '#FF00FF', '#FFFFFF'];

            for (let i = 0; i < count; i++) {
                confettiPieces.push({
                    x: Math.random() * confettiCanvas.width,
                    y: -20 - Math.random() * 200,
                    size: 5 + Math.random() * 10,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 10,
                    speedX: (Math.random() - 0.5) * 4,
                    speedY: 2 + Math.random() * 4,
                    wobble: Math.random() * Math.PI * 2,
                    wobbleSpeed: 0.05 + Math.random() * 0.1,
                });
            }
        }

        function animateConfetti() {
            if (!confettiAnimating) return;

            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);

            let activeCount = 0;

            confettiPieces.forEach(p => {
                if (p.y < confettiCanvas.height + 50) {
                    activeCount++;

                    p.y += p.speedY;
                    p.x += p.speedX + Math.sin(p.wobble) * 2;
                    p.wobble += p.wobbleSpeed;
                    p.rotation += p.rotationSpeed;
                    p.speedY += 0.05; // Gravity

                    confettiCtx.save();
                    confettiCtx.translate(p.x, p.y);
                    confettiCtx.rotate(p.rotation * Math.PI / 180);
                    confettiCtx.fillStyle = p.color;
                    confettiCtx.fillRect(-p.size / 2, -p.size / 4, p.size, p.size / 2);
                    confettiCtx.restore();
                }
            });

            if (activeCount > 0) {
                requestAnimationFrame(animateConfetti);
            } else {
                confettiAnimating = false;
                confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
            }
        }

        function startConfetti() {
            createConfetti(200);
            confettiAnimating = true;
            animateConfetti();

            // Zweite Welle
            setTimeout(() => {
                if (confettiAnimating) {
                    const colors = ['#FFD700', '#FF6600', '#FF0000', '#00FF00', '#00BFFF', '#FF00FF', '#FFFFFF'];
                    for (let i = 0; i < 100; i++) {
                        confettiPieces.push({
                            x: Math.random() * confettiCanvas.width,
                            y: -20 - Math.random() * 100,
                            size: 5 + Math.random() * 10,
                            color: colors[Math.floor(Math.random() * colors.length)],
                            rotation: Math.random() * 360,
                            rotationSpeed: (Math.random() - 0.5) * 10,
                            speedX: (Math.random() - 0.5) * 4,
                            speedY: 2 + Math.random() * 4,
                            wobble: Math.random() * Math.PI * 2,
                            wobbleSpeed: 0.05 + Math.random() * 0.1,
                        });
                    }
                }
            }, 500);
        }

        function playHighscoreSound() {
            if (!audioCtx) return;

            const masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);
            masterGain.gain.value = sfxVolume;

            // Triumphale Fanfare
            const notes = [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50, 1318.51];
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    playSfxChord([freq, freq * 1.25, freq * 1.5], 0.3, 'sine', masterGain);
                }, i * 150);
            });
        }

        function checkNewHighscore(currentScore) {
            const highscores = getHighscores();
            if (highscores.length === 0) return true;
            return currentScore > highscores[0].score;
        }

        // ==================== DIFFICULTY SETTINGS ====================
        const difficultySettings = {
            1:  { speedMult: 1.0, spawnRate: 0.015, sunChance: 0.08, sunSpeed: 2.5, sunSize: 55 },
            2:  { speedMult: 1.15, spawnRate: 0.018, sunChance: 0.07, sunSpeed: 2.8, sunSize: 52 },
            3:  { speedMult: 1.3, spawnRate: 0.02, sunChance: 0.06, sunSpeed: 3.2, sunSize: 50 },
            4:  { speedMult: 1.45, spawnRate: 0.022, sunChance: 0.055, sunSpeed: 3.5, sunSize: 48 },
            5:  { speedMult: 1.6, spawnRate: 0.025, sunChance: 0.05, sunSpeed: 3.8, sunSize: 45 },
            6:  { speedMult: 1.8, spawnRate: 0.028, sunChance: 0.045, sunSpeed: 4.2, sunSize: 42 },
            7:  { speedMult: 2.0, spawnRate: 0.03, sunChance: 0.04, sunSpeed: 4.5, sunSize: 40 },
            8:  { speedMult: 2.2, spawnRate: 0.033, sunChance: 0.035, sunSpeed: 5.0, sunSize: 38 },
            9:  { speedMult: 2.5, spawnRate: 0.035, sunChance: 0.03, sunSpeed: 5.5, sunSize: 35 },
            10: { speedMult: 3.0, spawnRate: 0.04, sunChance: 0.025, sunSpeed: 6.0, sunSize: 32 }
        };

        // Symbol Types - Sun is special and harder
        function getSymbolTypes() {
            const diff = difficultySettings[level] || difficultySettings[10];
            return [
                { name: 'sun', points: 500, sound: 'jackpot', size: diff.sunSize, spawnChance: diff.sunChance, speedBonus: diff.sunSpeed, hitboxMult: 0.6 },
                { name: 'diamond', points: 300, sound: 'chaching', size: 55, spawnChance: 0.1, speedBonus: 1.5, hitboxMult: 0.75 },
                { name: 'bell', points: 200, sound: 'bell', size: 50, spawnChance: 0.15, speedBonus: 1.2, hitboxMult: 0.8 },
                { name: 'melon', points: 100, sound: 'coin', size: 50, spawnChance: 0.2, speedBonus: 1.0, hitboxMult: 0.85 },
                { name: 'orange', points: 50, sound: 'plop', size: 45, spawnChance: 0.22, speedBonus: 0.9, hitboxMult: 0.9 },
                { name: 'cherry', points: 25, sound: 'ping', size: 40, spawnChance: 0.25, speedBonus: 0.8, hitboxMult: 0.95 }
            ];
        }

        // ==================== DRAWING FUNCTIONS ====================
        function drawSun(x, y, size, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation * 0.03);

            const scale = size / 80;
            ctx.scale(scale, scale);

            // Strahlen
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;

            for (let i = 0; i < 12; i++) {
                ctx.save();
                ctx.rotate((i * 30) * Math.PI / 180);
                ctx.beginPath();
                ctx.moveTo(-12, -35);
                ctx.lineTo(0, -70);
                ctx.lineTo(12, -35);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }

            // Gesicht (Kreis)
            ctx.beginPath();
            ctx.arc(0, 0, 35, 0, Math.PI * 2);
            ctx.fillStyle = '#FFFEF0';
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Augen
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(-12, -8, 5, 7, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.ellipse(12, -8, 5, 7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nase
            ctx.beginPath();
            ctx.moveTo(0, -2);
            ctx.quadraticCurveTo(8, 5, 0, 8);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Mund (gro√ües Grinsen)
            ctx.beginPath();
            ctx.arc(0, 8, 18, 0.1 * Math.PI, 0.9 * Math.PI);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.restore();
        }

        function drawDiamond(x, y, size, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.sin(rotation * 0.05) * 0.1);

            const s = size / 2;

            ctx.beginPath();
            ctx.moveTo(0, -s);
            ctx.lineTo(s * 0.7, -s * 0.3);
            ctx.lineTo(s, s * 0.2);
            ctx.lineTo(0, s);
            ctx.lineTo(-s, s * 0.2);
            ctx.lineTo(-s * 0.7, -s * 0.3);
            ctx.closePath();

            const gradient = ctx.createLinearGradient(-s, -s, s, s);
            gradient.addColorStop(0, '#E0FFFF');
            gradient.addColorStop(0.3, '#87CEEB');
            gradient.addColorStop(0.5, '#FFFFFF');
            gradient.addColorStop(0.7, '#87CEEB');
            gradient.addColorStop(1, '#4169E1');

            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#1E90FF';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(-s * 0.7, -s * 0.3);
            ctx.lineTo(0, s * 0.2);
            ctx.lineTo(s * 0.7, -s * 0.3);
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();
        }

        function drawBell(x, y, size, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.sin(rotation * 0.1) * 0.15);

            const s = size / 2;

            ctx.beginPath();
            ctx.moveTo(-s * 0.8, s * 0.6);
            ctx.quadraticCurveTo(-s * 0.8, -s * 0.2, -s * 0.3, -s * 0.6);
            ctx.quadraticCurveTo(0, -s * 0.9, s * 0.3, -s * 0.6);
            ctx.quadraticCurveTo(s * 0.8, -s * 0.2, s * 0.8, s * 0.6);
            ctx.lineTo(-s * 0.8, s * 0.6);
            ctx.closePath();

            const gradient = ctx.createLinearGradient(-s, 0, s, 0);
            gradient.addColorStop(0, '#DAA520');
            gradient.addColorStop(0.3, '#FFD700');
            gradient.addColorStop(0.5, '#FFEC8B');
            gradient.addColorStop(0.7, '#FFD700');
            gradient.addColorStop(1, '#B8860B');

            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#8B7500';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(0, s * 0.5, s * 0.15, 0, Math.PI * 2);
            ctx.fillStyle = '#8B4513';
            ctx.fill();
            ctx.strokeStyle = '#5D3A1A';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(0, -s * 0.7, s * 0.12, 0, Math.PI * 2);
            ctx.fillStyle = '#FFD700';
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }

        function drawMelon(x, y, size, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.sin(rotation * 0.03) * 0.05);

            const s = size / 2;

            ctx.beginPath();
            ctx.ellipse(0, 0, s, s * 0.7, 0, 0, Math.PI * 2);

            const gradient = ctx.createRadialGradient(s * 0.3, -s * 0.3, 0, 0, 0, s);
            gradient.addColorStop(0, '#90EE90');
            gradient.addColorStop(0.6, '#228B22');
            gradient.addColorStop(1, '#006400');

            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#004D00';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.strokeStyle = '#006400';
            ctx.lineWidth = 2;
            for (let i = -2; i <= 2; i++) {
                ctx.beginPath();
                ctx.moveTo(i * s * 0.3, -s * 0.6);
                ctx.quadraticCurveTo(i * s * 0.35, 0, i * s * 0.3, s * 0.6);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawOrange(x, y, size, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation * 0.02);

            const s = size / 2;

            ctx.beginPath();
            ctx.arc(0, 0, s, 0, Math.PI * 2);

            const gradient = ctx.createRadialGradient(s * 0.3, -s * 0.3, 0, 0, 0, s);
            gradient.addColorStop(0, '#FFD700');
            gradient.addColorStop(0.5, '#FFA500');
            gradient.addColorStop(1, '#FF8C00');

            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#CC7000';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.beginPath();
            ctx.ellipse(0, -s * 0.9, s * 0.3, s * 0.15, 0.3, 0, Math.PI * 2);
            ctx.fillStyle = '#228B22';
            ctx.fill();
            ctx.strokeStyle = '#006400';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();
        }

        function drawCherry(x, y, size, rotation) {
            ctx.save();
            ctx.translate(x, y);

            const s = size / 2;

            ctx.beginPath();
            ctx.moveTo(-s * 0.3, -s * 0.3);
            ctx.quadraticCurveTo(-s * 0.1, -s * 0.8, s * 0.2, -s);
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(s * 0.3, -s * 0.1);
            ctx.quadraticCurveTo(s * 0.3, -s * 0.6, s * 0.2, -s);
            ctx.stroke();

            ctx.beginPath();
            ctx.ellipse(s * 0.35, -s * 0.85, s * 0.25, s * 0.12, 0.5, 0, Math.PI * 2);
            ctx.fillStyle = '#228B22';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(-s * 0.35, s * 0.2, s * 0.45, 0, Math.PI * 2);

            let gradient = ctx.createRadialGradient(-s * 0.2, 0, 0, -s * 0.35, s * 0.2, s * 0.45);
            gradient.addColorStop(0, '#FF6B6B');
            gradient.addColorStop(0.5, '#DC143C');
            gradient.addColorStop(1, '#8B0000');

            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#600000';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(-s * 0.45, s * 0.05, s * 0.1, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(s * 0.35, s * 0.35, s * 0.4, 0, Math.PI * 2);

            gradient = ctx.createRadialGradient(s * 0.45, s * 0.2, 0, s * 0.35, s * 0.35, s * 0.4);
            gradient.addColorStop(0, '#FF6B6B');
            gradient.addColorStop(0.5, '#DC143C');
            gradient.addColorStop(1, '#8B0000');

            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#600000';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(s * 0.25, s * 0.2, s * 0.08, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.fill();

            ctx.restore();
        }

        function drawTarget(target) {
            switch(target.type.name) {
                case 'sun': drawSun(target.x, target.y, target.size, target.rotation); break;
                case 'diamond': drawDiamond(target.x, target.y, target.size, target.rotation); break;
                case 'bell': drawBell(target.x, target.y, target.size, target.rotation); break;
                case 'melon': drawMelon(target.x, target.y, target.size, target.rotation); break;
                case 'orange': drawOrange(target.x, target.y, target.size, target.rotation); break;
                case 'cherry': drawCherry(target.x, target.y, target.size, target.rotation); break;
            }
        }

        // ==================== BACKGROUND (STATIC) ====================
        function drawBackground() {
            const width = bgCanvas.width;
            const height = bgCanvas.height;

            // Sky gradient (night)
            const skyGradient = bgCtx.createLinearGradient(0, 0, 0, height);
            skyGradient.addColorStop(0, '#0a0a2e');
            skyGradient.addColorStop(0.3, '#1a1a4e');
            skyGradient.addColorStop(0.6, '#2d1f5e');
            skyGradient.addColorStop(1, '#4a3070');
            bgCtx.fillStyle = skyGradient;
            bgCtx.fillRect(0, 0, width, height);

            // Stars (fixed positions based on seed)
            bgCtx.fillStyle = '#FFF';
            for (let i = 0; i < 150; i++) {
                const x = (i * 137.508) % width;
                const y = (i * 73.337) % (height * 0.5);
                const size = ((i * 17) % 3) + 1;
                bgCtx.beginPath();
                bgCtx.arc(x, y, size, 0, Math.PI * 2);
                bgCtx.fill();
            }

            const buildingColors = ['#1a1a2e', '#16213e', '#0f3460', '#1a1a3e'];
            const neonColors = ['#ff006e', '#00f5ff', '#ffbe0b', '#8338ec', '#ff006e', '#00ff87'];

            // Background buildings
            for (let i = 0; i < 20; i++) {
                const x = i * (width / 15) - 50;
                const bWidth = 60 + ((i * 47) % 80);
                const bHeight = 120 + ((i * 67) % 220);
                const y = height - bHeight - 80;

                bgCtx.fillStyle = buildingColors[i % buildingColors.length];
                bgCtx.fillRect(x, y, bWidth, bHeight + 100);

                // Windows
                bgCtx.fillStyle = 'rgba(255, 255, 200, 0.3)';
                for (let wy = y + 20; wy < y + bHeight; wy += 20) {
                    for (let wx = x + 10; wx < x + bWidth - 10; wx += 15) {
                        if (((wx * wy * i) % 10) > 3) {
                            bgCtx.fillRect(wx, wy, 8, 12);
                        }
                    }
                }
            }

            // Main Strip buildings
            const mainBuildings = [
                { x: width * 0.02, w: 100, h: 320, spire: true },
                { x: width * 0.12, w: 140, h: 260, dome: true },
                { x: width * 0.25, w: 110, h: 380, spire: true },
                { x: width * 0.38, w: 160, h: 300, sign: 'CASINO' },
                { x: width * 0.52, w: 130, h: 350, pyramid: true },
                { x: width * 0.65, w: 120, h: 280, dome: true },
                { x: width * 0.77, w: 150, h: 310, sign: 'VEGAS' },
                { x: width * 0.9, w: 100, h: 340, spire: true }
            ];

            mainBuildings.forEach((b, i) => {
                const y = height - b.h - 50;

                // Building body
                const bGradient = bgCtx.createLinearGradient(b.x, y, b.x + b.w, y);
                bGradient.addColorStop(0, '#1a1a2e');
                bGradient.addColorStop(0.5, '#252545');
                bGradient.addColorStop(1, '#1a1a2e');
                bgCtx.fillStyle = bGradient;
                bgCtx.fillRect(b.x, y, b.w, b.h + 60);

                // Neon outline
                bgCtx.strokeStyle = neonColors[i % neonColors.length];
                bgCtx.lineWidth = 3;
                bgCtx.shadowColor = neonColors[i % neonColors.length];
                bgCtx.shadowBlur = 15;
                bgCtx.strokeRect(b.x, y, b.w, b.h);
                bgCtx.shadowBlur = 0;

                // Windows
                for (let wy = y + 15; wy < y + b.h - 20; wy += 18) {
                    for (let wx = b.x + 12; wx < b.x + b.w - 12; wx += 16) {
                        if (((wx + wy + i) % 5) > 1) {
                            bgCtx.fillStyle = ((wx * wy) % 7) > 4 ?
                                'rgba(255,200,100, 0.6)' : 'rgba(255, 255, 200, 0.4)';
                            bgCtx.fillRect(wx, wy, 10, 12);
                        }
                    }
                }

                // Spire
                if (b.spire) {
                    bgCtx.beginPath();
                    bgCtx.moveTo(b.x + b.w / 2, y - 60);
                    bgCtx.lineTo(b.x + b.w / 2 - 15, y);
                    bgCtx.lineTo(b.x + b.w / 2 + 15, y);
                    bgCtx.closePath();
                    bgCtx.fillStyle = '#2a2a4a';
                    bgCtx.fill();

                    bgCtx.beginPath();
                    bgCtx.arc(b.x + b.w / 2, y - 55, 5, 0, Math.PI * 2);
                    bgCtx.fillStyle = '#ff0000';
                    bgCtx.shadowColor = '#ff0000';
                    bgCtx.shadowBlur = 20;
                    bgCtx.fill();
                    bgCtx.shadowBlur = 0;
                }

                // Dome
                if (b.dome) {
                    bgCtx.beginPath();
                    bgCtx.arc(b.x + b.w / 2, y, b.w / 2.5, Math.PI, 0);
                    bgCtx.fillStyle = '#3a3a5a';
                    bgCtx.fill();
                    bgCtx.strokeStyle = neonColors[(i + 2) % neonColors.length];
                    bgCtx.shadowColor = neonColors[(i + 2) % neonColors.length];
                    bgCtx.shadowBlur = 10;
                    bgCtx.stroke();
                    bgCtx.shadowBlur = 0;
                }

                // Pyramid
                if (b.pyramid) {
                    bgCtx.beginPath();
                    bgCtx.moveTo(b.x + b.w / 2, y - 80);
                    bgCtx.lineTo(b.x - 20, y + b.h);
                    bgCtx.lineTo(b.x + b.w + 20, y + b.h);
                    bgCtx.closePath();
                    bgCtx.fillStyle = '#1a1a2e';
                    bgCtx.fill();
                    bgCtx.strokeStyle = '#FFD700';
                    bgCtx.shadowColor = '#FFD700';
                    bgCtx.shadowBlur = 15;
                    bgCtx.stroke();
                    bgCtx.shadowBlur = 0;
                }

                // Neon Sign
                if (b.sign) {
                    bgCtx.fillStyle = neonColors[i % neonColors.length];
                    bgCtx.shadowColor = neonColors[i % neonColors.length];
                    bgCtx.shadowBlur = 20;
                    bgCtx.font = 'bold 22px Arial';
                    bgCtx.textAlign = 'center';
                    bgCtx.fillText(b.sign, b.x + b.w / 2, y + 40);
                    bgCtx.shadowBlur = 0;
                }
            });

            // Ground/Street
            bgCtx.fillStyle = '#1a1a1a';
            bgCtx.fillRect(0, height - 50, width, 50);

            // Street lights reflection
            for (let i = 0; i < width; i += 150) {
                const gradient = bgCtx.createRadialGradient(i, height - 40, 0, i, height - 40, 60);
                gradient.addColorStop(0, 'rgba(255, 200, 100, 0.3)');
                gradient.addColorStop(1, 'transparent');
                bgCtx.fillStyle = gradient;
                bgCtx.fillRect(i - 60, height - 50, 120, 50);
            }
        }

        // ==================== TARGET SPAWNING ====================
        function spawnTarget() {
            const symbolTypes = getSymbolTypes();
            const rand = Math.random();
            let cumulative = 0;
            let selectedType = symbolTypes[symbolTypes.length - 1];

            for (const type of symbolTypes) {
                cumulative += type.spawnChance;
                if (rand < cumulative) {
                    selectedType = type;
                    break;
                }
            }

            const diff = difficultySettings[level] || difficultySettings[10];
            const baseSpeed = 1.5 + Math.random() * 2;
            const speed = baseSpeed * diff.speedMult * selectedType.speedBonus;

            // Spawn from sides or top
            const side = Math.floor(Math.random() * 3);
            let x, y, vx, vy;

            if (side === 0) { // Left
                x = -selectedType.size;
                y = 80 + Math.random() * (canvas.height - 250);
                vx = speed;
                vy = (Math.random() - 0.5) * 2 * diff.speedMult;
            } else if (side === 1) { // Right
                x = canvas.width + selectedType.size;
                y = 80 + Math.random() * (canvas.height - 250);
                vx = -speed;
                vy = (Math.random() - 0.5) * 2 * diff.speedMult;
            } else { // Top
                x = 100 + Math.random() * (canvas.width - 200);
                y = -selectedType.size;
                vx = (Math.random() - 0.5) * 3 * diff.speedMult;
                vy = speed * 0.7;
            }

            // Sun has erratic movement
            let movePattern = 'linear';
            if (selectedType.name === 'sun') {
                movePattern = Math.random() > 0.5 ? 'sine' : 'zigzag';
            } else if (selectedType.name === 'diamond') {
                movePattern = Math.random() > 0.7 ? 'sine' : 'linear';
            }

            targets.push({
                x, y, vx, vy,
                type: selectedType,
                size: selectedType.size,
                rotation: 0,
                alive: true,
                movePattern,
                movePhase: Math.random() * Math.PI * 2,
                moveAmplitude: 2 + Math.random() * 3
            });
        }

        // ==================== PARTICLES ====================
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 1,
                    color,
                    size: 3 + Math.random() * 6
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.3;
                p.life -= 0.025;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        // ==================== HIT EFFECTS ====================
        function showHitEffect(x, y, points, isCombo) {
            const effect = document.getElementById('hitEffect');
            const comboText = isCombo && combo > 1 ? ` x${combo}` : '';
            effect.textContent = '+' + points + comboText;
            effect.style.left = x + 'px';
            effect.style.top = y + 'px';
            effect.style.color = points >= 300 ? '#FFD700' : (points >= 100 ? '#00FF00' : '#FFFFFF');
            effect.style.display = 'block';
            effect.style.animation = 'none';
            effect.offsetHeight;
            effect.style.animation = 'floatUp 1s ease-out forwards';

            setTimeout(() => {
                effect.style.display = 'none';
            }, 1000);
        }

        function showMuzzleFlash(x, y) {
            const flash = document.getElementById('muzzleFlash');
            flash.style.left = x + 'px';
            flash.style.top = y + 'px';
            flash.style.display = 'block';
            setTimeout(() => {
                flash.style.display = 'none';
            }, 100);
        }

        // ==================== INPUT HANDLING ====================
        function handleShot(x, y) {
            if (!gameRunning || gamePaused) return;

            initAudio();
            playSound('shoot');
            showMuzzleFlash(x, y);
            shotsFired++;

            let hit = false;

            // Check hits (reverse order for proper z-index)
            for (let i = targets.length - 1; i >= 0; i--) {
                const t = targets[i];
                const dx = x - t.x;
                const dy = y - t.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const hitRadius = (t.size / 2) * t.type.hitboxMult;

                if (dist < hitRadius) {
                    hit = true;
                    shotsHit++;

                    // Combo system
                    const now = Date.now();
                    if (now - lastHitTime < 1500) {
                        combo = Math.min(combo + 1, 10);
                        // Sarkastischer Spruch bei hohem Combo
                        if (combo === 5 || combo === 8 || combo === 10) {
                            showSnarkyMessage(getRandomSnarky('highCombo'), 1500);
                        }
                    } else {
                        combo = 1;
                    }
                    lastHitTime = now;
                    missStreak = 0;

                    const points = Math.floor(t.type.points * combo);
                    score += points;
                    playSound(t.type.sound);
                    showHitEffect(t.x, t.y, points, combo > 1);

                    // Particles
                    const colors = {
                        'sun': '#FFD700',
                        'diamond': '#00BFFF',
                        'bell': '#FFD700',
                        'melon': '#32CD32',
                        'orange': '#FFA500',
                        'cherry': '#DC143C'
                    };
                    createParticles(t.x, t.y, colors[t.type.name], 20);

                    targets.splice(i, 1);
                    updateUI();
                    break;
                }
            }

            if (!hit) {
                missStreak++;
                if (missStreak >= 3) {
                    combo = 1;
                }
                // Sarkastischer Spruch bei vielen Misses
                if (missStreak === 5 || missStreak === 10) {
                    showSnarkyMessage(getRandomSnarky('missStreak'), 1800);
                }
            }
        }

        // Mouse support
        canvas.addEventListener('click', (e) => {
            handleShot(e.clientX, e.clientY);
        });

        document.addEventListener('mousemove', (e) => {
            const crosshair = document.getElementById('crosshair');
            crosshair.style.left = e.clientX + 'px';
            crosshair.style.top = e.clientY + 'px';
        });

        // Touch support for iPad/tablets
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleShot(touch.clientX, touch.clientY);

            // Move crosshair to touch position
            const crosshair = document.getElementById('crosshair');
            crosshair.style.left = touch.clientX + 'px';
            crosshair.style.top = touch.clientY + 'px';
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const crosshair = document.getElementById('crosshair');
            crosshair.style.left = touch.clientX + 'px';
            crosshair.style.top = touch.clientY + 'px';
        }, { passive: false });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
                if (gameRunning && !gamePaused) {
                    pauseGame();
                } else if (gameRunning && gamePaused) {
                    resumeGame();
                }
            }
            if (e.key === 'm' || e.key === 'M') {
                toggleMusic();
            }
        });

        // ==================== UI UPDATE ====================
        function updateUI() {
            document.getElementById('scoreDisplay').textContent = 'PUNKTE: ' + score;
            document.getElementById('levelDisplay').textContent = 'LEVEL: ' + level;
            document.getElementById('timeDisplay').textContent = 'ZEIT: ' + timeLeft;
            document.getElementById('comboDisplay').textContent = 'KOMBO: x' + combo;
            document.getElementById('comboDisplay').style.color = combo > 1 ? '#00FF00' : '#FFD700';
        }

        // ==================== GAME LOOP ====================
        function gameLoop() {
            if (!gameRunning) return;

            if (!gamePaused) {
                // Clear game canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const diff = difficultySettings[level] || difficultySettings[10];

                // Spawn targets
                if (Math.random() < diff.spawnRate) {
                    spawnTarget();
                }

                // Update and draw targets
                for (let i = targets.length - 1; i >= 0; i--) {
                    const t = targets[i];

                    // Movement patterns
                    if (t.movePattern === 'sine') {
                        t.movePhase += 0.1;
                        if (Math.abs(t.vx) > Math.abs(t.vy)) {
                            t.y += Math.sin(t.movePhase) * t.moveAmplitude;
                        } else {
                            t.x += Math.sin(t.movePhase) * t.moveAmplitude;
                        }
                    } else if (t.movePattern === 'zigzag') {
                        t.movePhase += 0.15;
                        if (Math.abs(t.vx) > Math.abs(t.vy)) {
                            t.y += Math.sign(Math.sin(t.movePhase)) * t.moveAmplitude * 0.5;
                        } else {
                            t.x += Math.sign(Math.sin(t.movePhase)) * t.moveAmplitude * 0.5;
                        }
                    }

                    t.x += t.vx;
                    t.y += t.vy;
                    t.rotation++;

                    // Remove if off screen
                    if (t.x < -150 || t.x > canvas.width + 150 ||
                        t.y < -150 || t.y > canvas.height + 150) {
                        targets.splice(i, 1);
                        continue;
                    }

                    drawTarget(t);
                }

                // Update and draw particles
                updateParticles();
                drawParticles();
            }

            requestAnimationFrame(gameLoop);
        }

        // ==================== TIMER ====================
        function startTimer() {
            timerInterval = setInterval(() => {
                if (!gamePaused) {
                    timeLeft--;
                    updateUI();

                    if (timeLeft <= 0) {
                        levelComplete();
                    }
                }
            }, 1000);
        }

        // ==================== LEVEL MANAGEMENT ====================
        function levelComplete() {
            clearInterval(timerInterval);
            gameRunning = false;

            initAudio();

            if (level >= 10) {
                gameOver();
                return;
            }

            playSound('levelup');

            document.getElementById('pauseBtn').classList.add('hidden');

            const accuracy = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) : 0;
            const bonus = Math.floor(score * 0.1) + (accuracy * 10);
            score += bonus;

            document.getElementById('levelSnarky').textContent = '"' + getRandomSnarky('levelComplete') + '"';
            document.getElementById('levelScore').textContent = 'Punkte: ' + score;
            document.getElementById('levelBonus').textContent = 'Level Bonus: +' + bonus;
            document.getElementById('levelAccuracy').textContent = 'Trefferquote: ' + accuracy + '%';
            document.getElementById('levelComplete').classList.remove('hidden');
        }

        function nextLevel() {
            document.getElementById('levelComplete').classList.add('hidden');
            document.getElementById('pauseBtn').classList.remove('hidden');
            level++;
            timeLeft = 60;
            targets = [];
            shotsFired = 0;
            shotsHit = 0;
            combo = 1;
            gameRunning = true;
            updateUI();
            startTimer();
            gameLoop();
        }

        function gameOver() {
            clearInterval(timerInterval);
            gameRunning = false;
            stopBackgroundMusic();

            initAudio();

            document.getElementById('pauseBtn').classList.add('hidden');

            const accuracy = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) : 0;
            const isNewHighscore = checkNewHighscore(score);

            // Sarkastischen Spruch ausw√§hlen
            let snarkyCategory;
            if (isNewHighscore) {
                snarkyCategory = 'newHighscore';
            } else if (score < 1000) {
                snarkyCategory = 'gameOverBad';
            } else if (score < 5000) {
                snarkyCategory = 'gameOverMeh';
            } else if (score < 15000) {
                snarkyCategory = 'gameOverGood';
            } else {
                snarkyCategory = 'gameOverAmazing';
            }

            const gameOverBox = document.getElementById('gameOverBox');
            const badge = document.getElementById('newHighscoreBadge');
            const snarkyEl = document.getElementById('gameOverSnarky');
            const titleEl = document.getElementById('gameOverTitle');

            if (isNewHighscore) {
                // NEUER HIGHSCORE!
                playHighscoreSound();
                startConfetti();
                titleEl.textContent = 'üèÜ NEUER HIGHSCORE! üèÜ';
                badge.classList.remove('hidden');
                gameOverBox.classList.add('highscore-celebration');
            } else {
                playSound('gameover');
                titleEl.textContent = 'üíÄ SPIEL VORBEI!';
                badge.classList.add('hidden');
                gameOverBox.classList.remove('highscore-celebration');
            }

            snarkyEl.textContent = '"' + getRandomSnarky(snarkyCategory) + '"';

            document.getElementById('finalScore').textContent = 'Endpunktzahl: ' + score;
            document.getElementById('finalLevel').textContent = 'Erreichtes Level: ' + level;
            document.getElementById('finalAccuracy').textContent = 'Trefferquote: ' + accuracy + '%';
            document.getElementById('gameOver').classList.remove('hidden');
        }

        // ==================== PAUSE SYSTEM ====================
        function pauseGame() {
            if (!gameRunning || gamePaused) return;
            gamePaused = true;
            document.getElementById('pauseLevel').textContent = level;
            document.getElementById('pauseScore').textContent = score;
            document.getElementById('pauseMenu').classList.remove('hidden');
            document.getElementById('pauseBtn').classList.add('hidden');
            document.getElementById('pauseIndicator').style.display = 'none';
        }

        function resumeGame() {
            gamePaused = false;
            document.getElementById('pauseMenu').classList.add('hidden');
            document.getElementById('saveMenu').classList.add('hidden');
            document.getElementById('settingsMenu').classList.add('hidden');
            document.getElementById('pauseBtn').classList.remove('hidden');
        }

        // ==================== SAVE/LOAD SYSTEM ====================
        function getSaveSlots() {
            const saves = localStorage.getItem('sunHunterSaves');
            return saves ? JSON.parse(saves) : [{}, {}, {}];
        }

        function setSaveSlots(slots) {
            localStorage.setItem('sunHunterSaves', JSON.stringify(slots));
        }

        function saveGame(slotIndex) {
            const playerName = document.getElementById('savePlayerName').value || 'Spieler';
            const slots = getSaveSlots();
            slots[slotIndex] = {
                playerName,
                score,
                level,
                timeLeft,
                shotsFired,
                shotsHit,
                date: new Date().toLocaleString('de-DE')
            };
            setSaveSlots(slots);
            renderSaveSlots();
            renderLoadSlots();
        }

        function loadGame(slotIndex) {
            const slots = getSaveSlots();
            const save = slots[slotIndex];
            if (!save || !save.score) return false;

            score = save.score;
            level = save.level;
            timeLeft = save.timeLeft;
            shotsFired = save.shotsFired || 0;
            shotsHit = save.shotsHit || 0;
            combo = 1;
            targets = [];
            particles = [];

            return true;
        }

        function deleteSave(slotIndex) {
            const slots = getSaveSlots();
            slots[slotIndex] = {};
            setSaveSlots(slots);
            renderSaveSlots();
            renderLoadSlots();
        }

        function renderSaveSlots() {
            const container = document.getElementById('saveSlots');
            const slots = getSaveSlots();
            container.innerHTML = '';

            slots.forEach((save, i) => {
                const div = document.createElement('div');
                div.className = 'save-slot' + (save.score ? ' has-save' : '');

                if (save.score) {
                    div.innerHTML = `
                        <div class="save-slot-info">
                            <div class="save-slot-name">Slot ${i + 1}: ${save.playerName || 'Spieler'}</div>
                            <div class="save-slot-details">Level ${save.level} | ${save.score} Punkte | ${save.date}</div>
                        </div>
                        <div>
                            <button class="btn btn-small" onclick="saveGame(${i})">√úberschreiben</button>
                            <button class="btn btn-small btn-danger" onclick="deleteSave(${i})">L√∂schen</button>
                        </div>
                    `;
                } else {
                    div.innerHTML = `
                        <div class="save-slot-info">
                            <div class="save-slot-name">Slot ${i + 1}</div>
                            <div class="save-slot-details">Leer</div>
                        </div>
                        <button class="btn btn-small" onclick="saveGame(${i})">Speichern</button>
                    `;
                }
                container.appendChild(div);
            });
        }

        function renderLoadSlots() {
            const container = document.getElementById('loadSlots');
            const slots = getSaveSlots();
            container.innerHTML = '';

            let hasAnySave = false;
            slots.forEach((save, i) => {
                if (save.score) {
                    hasAnySave = true;
                    const div = document.createElement('div');
                    div.className = 'save-slot has-save';
                    div.innerHTML = `
                        <div class="save-slot-info">
                            <div class="save-slot-name">Slot ${i + 1}: ${save.playerName || 'Spieler'}</div>
                            <div class="save-slot-details">Level ${save.level} | ${save.score} Punkte | ${save.date}</div>
                        </div>
                        <button class="btn btn-small" onclick="loadAndStart(${i})">Laden</button>
                    `;
                    container.appendChild(div);
                }
            });

            if (!hasAnySave) {
                container.innerHTML = '<p style="color: #AAA; padding: 20px;">Keine Spielst√§nde vorhanden.</p>';
            }
        }

        function loadAndStart(slotIndex) {
            if (loadGame(slotIndex)) {
                closeLoadMenu();
                document.getElementById('mainMenu').classList.add('hidden');
                document.getElementById('ui').classList.remove('hidden');
                document.getElementById('pauseBtn').classList.remove('hidden');
                gameRunning = true;
                gamePaused = false;
                updateUI();
                startTimer();
                gameLoop();
                initAudio();
                startBackgroundMusic();
            }
        }

        // ==================== MENU FUNCTIONS ====================
        function showSaveMenu() {
            renderSaveSlots();
            document.getElementById('pauseMenu').classList.add('hidden');
            document.getElementById('saveMenu').classList.remove('hidden');
        }

        function showSaveMenuAfterLevel() {
            renderSaveSlots();
            document.getElementById('levelComplete').classList.add('hidden');
            document.getElementById('saveMenu').classList.remove('hidden');
        }

        function closeSaveMenu() {
            document.getElementById('saveMenu').classList.add('hidden');
            if (gameRunning) {
                document.getElementById('pauseMenu').classList.remove('hidden');
            } else {
                document.getElementById('levelComplete').classList.remove('hidden');
            }
        }

        function showLoadMenu() {
            renderLoadSlots();
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('loadMenu').classList.remove('hidden');
        }

        function closeLoadMenu() {
            document.getElementById('loadMenu').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
        }

        function showSettings() {
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('settingsMenu').classList.remove('hidden');
        }

        function showSettingsInGame() {
            document.getElementById('pauseMenu').classList.add('hidden');
            document.getElementById('settingsMenu').classList.remove('hidden');
        }

        function closeSettings() {
            document.getElementById('settingsMenu').classList.add('hidden');
            if (gameRunning) {
                document.getElementById('pauseMenu').classList.remove('hidden');
            } else {
                document.getElementById('mainMenu').classList.remove('hidden');
            }
        }

        function quitToMenu() {
            clearInterval(timerInterval);
            gameRunning = false;
            gamePaused = false;
            stopBackgroundMusic();
            document.getElementById('pauseMenu').classList.add('hidden');
            document.getElementById('ui').classList.add('hidden');
            document.getElementById('pauseBtn').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
        }

        function quitToMenuFromGameOver() {
            document.getElementById('gameOver').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
        }

        // ==================== HIGHSCORES ====================
        function getHighscores() {
            const scores = localStorage.getItem('sunHunterHighscores');
            return scores ? JSON.parse(scores) : [];
        }

        function saveHighscore() {
            const name = document.getElementById('playerName').value || 'Anonym';
            const accuracy = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) : 0;
            const highscores = getHighscores();

            highscores.push({
                name,
                score,
                level,
                accuracy,
                date: new Date().toLocaleDateString('de-DE')
            });

            highscores.sort((a, b) => b.score - a.score);
            highscores.splice(10);

            localStorage.setItem('sunHunterHighscores', JSON.stringify(highscores));

            document.getElementById('gameOver').classList.add('hidden');
            showHighscores();
        }

        function showHighscores() {
            const highscores = getHighscores();
            const list = document.getElementById('highscoreList');
            list.innerHTML = '';

            if (highscores.length === 0) {
                list.innerHTML = '<li style="color: #AAA;">Noch keine Highscores!</li>';
            } else {
                highscores.forEach((hs, i) => {
                    const li = document.createElement('li');
                    li.textContent = `${i + 1}. ${hs.name} - ${hs.score} Punkte (Level ${hs.level}, ${hs.accuracy || 0}%)`;
                    list.appendChild(li);
                });
            }

            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('highscoresMenu').classList.remove('hidden');
        }

        function closeHighscores() {
            document.getElementById('highscoresMenu').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
        }

        // ==================== GAME START ====================
        function startNewGame() {
            initAudio();
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('ui').classList.remove('hidden');
            document.getElementById('pauseBtn').classList.remove('hidden');

            score = 0;
            level = 1;
            timeLeft = 60;
            targets = [];
            particles = [];
            shotsFired = 0;
            shotsHit = 0;
            combo = 1;
            gameRunning = true;
            gamePaused = false;

            updateUI();
            startTimer();
            gameLoop();
            startBackgroundMusic();
        }

        function restartGame() {
            document.getElementById('gameOver').classList.add('hidden');
            startNewGame();
        }

        // ==================== INITIALIZATION ====================
        loadVolumeSettings();
        drawBackground();
    </script>
</body>
</html>
